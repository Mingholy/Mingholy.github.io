
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>A Cup of Coffee</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Mingholy">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="A Cup of Coffee">
<meta property="og:url" content="http://ming-holy.space/page/4/index.html">
<meta property="og:site_name" content="A Cup of Coffee">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Cup of Coffee">

    
    <link rel="alternative" href="/atom.xml" title="A Cup of Coffee" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="A Cup of Coffee" title="A Cup of Coffee"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="A Cup of Coffee">A Cup of Coffee</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:ming-holy.space">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/07/SSH免密码部署-git-bash配置/" title="SSH免密码部署:git-bash配置" itemprop="url">SSH免密码部署:git-bash配置</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2016-03-07T11:10:29.000Z" itemprop="datePublished"> 发表于 2016-03-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在使用<code>hexo d</code>部署这个博客的时候，经常会遇到拒绝public key的问题，要求确认访问repository的权限或者确定repository存在。<br>而实际上按照github的说明我已经生成并添加了ssh key，并且使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>测试成功。<br>但是由于ssh-agent是一个临时进程，它存储公钥的方式也是写入一个临时的session，因此每次重启git-bash都会重置连接，于是每次都需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval &quot;$(ssh-agent -s)&quot;</div><div class="line">ssh-add ~/.ssh/id_rsa</div><div class="line">ssh-add -l</div></pre></td></tr></table></figure></p>
<p>走一遍才能正确部署。<br>
        
        
        <p class="article-more-link">
          
            <a href="/2016/03/07/SSH免密码部署-git-bash配置/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/SSH/">SSH</a>►<a class="article-category-link" href="/categories/SSH/Git/">Git</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/git/">git</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/07/SSH免密码部署-git-bash配置/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/07/SSH免密码部署-git-bash配置/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/03/07/编写可维护的JavaScript-第一部分/" title="编写可维护的JavaScript:第一部分" itemprop="url">编写可维护的JavaScript:第一部分</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2016-03-07T11:03:54.000Z" itemprop="datePublished"> 发表于 2016-03-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="基本格式化"><a href="#基本格式化" class="headerlink" title="基本格式化"></a>基本格式化</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>4空格为一个缩进单位。</p>
<h3 id="语句结尾"><a href="#语句结尾" class="headerlink" title="语句结尾"></a>语句结尾</h3><p>自动分号插入机制 ASI 会在大多数应该加分号的地方加分号但是这种自动机制可能会引起某些意外的错误。因此还是<strong>手动加分号</strong>，也不要省略分号。</p>
<h3 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h3><p>一般是80个字符的限制。  </p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>需要拆行的时候，在运算符后拆行，并且在拆行之后设置两个缩进。<br>如果是if语句这种，比如在判断条件语句拆行，它之后的执行主体只设置一个缩进。  </p>
<blockquote>
<p>例外:变量赋值时，第二行的位置应该和赋值运算符的位置保持对齐。  </p>
</blockquote>
        
        
        <p class="article-more-link">
          
            <a href="/2016/03/07/编写可维护的JavaScript-第一部分/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/03/07/编写可维护的JavaScript-第一部分/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/03/07/编写可维护的JavaScript-第一部分/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/15/证明-sqrt-2-是无理数/" title="证明根号2是无理数" itemprop="url">证明根号2是无理数</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2016-01-15T14:53:40.000Z" itemprop="datePublished"> 发表于 2016-01-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>设$\sqrt{2}$是有理数，则可表示成$\frac{n}{m}$，$m,n$均为有理数且互质。<br>于是$ n=\sqrt{2}m\Rightarrow n^2=2m^2 $，于是$n^2$为偶数，它又是个有理数，那么必有<br>$ n^2=(2n_1)^2=4n_{1}^{2} $。于是$ n^2=m^2=4n_{1}^{2} $，则有$ m^2=2n_{1}^{2} $，同理可知$m$也是偶数。<br>那么$m,n$必有公约数2，这与它们互质矛盾。<br>这样就证明了$\sqrt{2}$是无理数。</p>
<p>$\sqrt{3}$也类似。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数学/">数学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/上帝之语/">上帝之语</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/15/证明-sqrt-2-是无理数/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/15/证明-sqrt-2-是无理数/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/07/贪心算法证真/" title="贪心算法证真" itemprop="url">贪心算法证真</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2016-01-07T13:55:03.000Z" itemprop="datePublished"> 发表于 2016-01-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<h3 id="笔者按："><a href="#笔者按：" class="headerlink" title="笔者按："></a>笔者按：</h3><p>图论的高随祥老师说：一个命题，证伪容易，找出反例就好了。证真可不容易，你得保证它不存在错误的情况。<br>眭跃飞老师也提到：数学里，恒等是一件很麻烦的事情。<br>所以曾经多次被教导，说数学里的精华都在定理上，它们是人的逻辑思维与自然的事实规律最精密最完整的体现。为了确定它们的正确性，无数人付出了不可估量的努力。<br>因此这里依照我的兴趣，记录了一些碰到的简单有趣的命题的证真思路，仅供玩味。只有从小的地方发现它的精美绝妙之处，才能从大的地方发现数学之美。</p>
</blockquote>
<hr>
        
        
        <p class="article-more-link">
          
            <a href="/2016/01/07/贪心算法证真/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数学/">数学</a>►<a class="article-category-link" href="/categories/数学/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/上帝之语/">上帝之语</a><a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/07/贪心算法证真/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/07/贪心算法证真/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/01/hello-world/" title="Hello World" itemprop="url">Hello World</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2016-01-01T12:00:00.000Z" itemprop="datePublished"> 发表于 2016-01-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
            <a href="/2016/01/01/hello-world/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/01/hello-world/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/01/hello-world/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/18/Linux Kernel-11-18/" title="Linux内核 11-18" itemprop="url">Linux内核 11-18</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2015-11-18T12:30:00.000Z" itemprop="datePublished"> 发表于 2015-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="最后一节课"><a href="#最后一节课" class="headerlink" title="最后一节课"></a>最后一节课</h2><p><strong>清空页表页目录表的目的</strong></p>
<ul>
<li>与父进程脱离关系</li>
<li>准备形成缺页中断，引导进程加载（P位为0，引发缺页中断。）</li>
</ul>
<p>除了寄存器页表页目录表其他都是线性地址。<br><code>trap_init</code>引导缺页中断。<br>汇编<code>_page_fault</code>中<code>_do_no_page</code>调用缺页处理函数。<br><code>_do_wp_page</code>调用写保护处理函数。</p>
<blockquote>
<p>内核操作-共享资源-写保护只读处理。这里的只读操作只针对该页。在页表项中<code>rw</code>项置0。共享进程对父进程只读，子进程同样只读。如果需要写操作，不论哪个进程先发起写请求，首先<code>get_free_page</code>复制该页到新页，当写保护结束将这个页分配给另外一个进程。写实复制都以页为单位。<br>注意，页共享是父子进程都有页，缺页中断是没有页了。共享导致页写保护。加载进程导致缺页中断。</p>
</blockquote>
<p><code>do_no_page</code></p>
<ol>
<li>首先确认缺页中断是加载进程引起的。</li>
<li>接着确认是否可以通过共享获得页。</li>
<li><code>for</code>循环连读4个块。<code>block+1</code>让出文件头。</li>
<li><code>bread_page</code>是读一个页到缓冲区，占用4个块。读盘动作总要先申请缓冲区。</li>
<li>一次从文件上读取一个页大小。</li>
<li>缓冲区操作建立：<code>bh``request</code></li>
</ol>
<blockquote>
<p>加载进程-缺页<code>page_fault</code>引发硬件中断-进入内核态处理页<code>do_no_page</code>-中断返回加载进程的用户态。<br>如果页不够用，就继续缺页中断。<br>缺页-加载-运行 循环。</p>
</blockquote>
<p>问题：<code>_do_wp_page</code>中断怎么引发的？</p>
<blockquote>
<p>在<code>share_page</code>的<code>try_to_share</code>中，<code>if(phys_addr &amp; 0x41) != 0x01</code>。即置<code>P</code>和<code>Δ</code>为1。</p>
</blockquote>
<h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><p>最先启动退出的是进程自身。</p>
<p><code>_exit</code><br>链接器在应用程序上加上<code>_exit</code>。直接贴机器码。<br>通过<code>int80</code>到<code>sys_call</code>走系统中断那一套。<br><code>do_exit</code><br>执行各种内存释放操作。进程不能由进程本身创建。同样退出也不能由自己退出。需要由父进程来操作。此处只是发出请求，完成自身能够执行的任务：释放内存，清空进程槽，清空文件访问关系。等等。最后将进程的状态改为<code>TASK_ZOBIE</code>，<code>僵死状态</code>。<br><strong>注意现在还在int80状态下，而此时一般的<code>iret</code>已经无进程可以返回，所以只能<code>tell_father</code></strong>。<br>这就涉及进程间通讯。(参见第八章)</p>
<blockquote>
<p>考虑到进程之间有非常明确的边界，如何实现这种需求？</p>
<ul>
<li>管道。<br>思路：进程都可以读写盘。但是盘读写速度太慢。改用内存。使用文件的形式，存在内存里。发信进程存盘，收信进程读盘。在内存的虚拟盘中，由通讯双方独享的一个小缓冲区。</li>
<li>信号。<br>思路：退出进程遗留部分需要父进程处理。一个父进程可以有多个子进程。如何得到进程退出的信息？轮询？中断？<br>实际：仿中断。软中断。所有的进程都有<code>int80</code>，就利用这个。</li>
</ul>
</blockquote>
<p><code>tell_father</code>向父进程发送子进程退出信号。只要父进程使用<code>int80</code>就将接收到信号。<br>发送信号之后调用<code>schedule</code>。<br>一旦调度到父进程，<code>schedule</code>肯定不是第一次运行，一定从中间(<code>ljmp</code>下一行)运行回到<code>ret_from_sys_call</code>，这其中就有一个信号处理函数<code>_do_signal</code>。随后清栈，<code>iret</code>后回到<code>int80</code>下一行。如果没有<code>_do_signal</code>父进程将回到用户态继续运行。而现在由于它的存在，进程就指向了<code>wait</code>。由它引发<code>sys_waitpid</code>(<strong>书上419页，<code>_do_signal</code></strong>)。此间内核态到用户态如何转换？软中断<code>int80</code>时，保存现场压栈，栈是内核栈，内容是用户态时调用<code>int80</code>的下一行。也就是说内核栈弹出的内容将是用户态。现在就将内核栈上保存的内容，复制到用户栈上。然后修改内核栈，使进程转向父进程的<code>wait</code>，再<code>int80</code>执行<code>sys_waitpid</code>开始清理。清理结束之后就要根据用户栈内容到回到父进程的用户态。至此子进程退出彻底完成。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/操作系统/">操作系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/18/Linux Kernel-11-18/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/18/Linux Kernel-11-18/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/16/Linux Kernel-11-16/" title="Linux内核 11-16" itemprop="url">Linux内核 11-16</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2015-11-16T12:30:00.000Z" itemprop="datePublished"> 发表于 2015-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>##进程的加载与退出</p>
<p><code>云里雾里</code></p>
<p><code>do_execve</code></p>
<p><code>文件头</code>：通过文件头确定文件类型。首先将文件头读取缓冲区，在缓冲区确认这个信息。</p>
<p>现在我们要加载一个可执行文件。加载它就需要创建进程。父进程创建子进程之后，要么共享父进程的资源，包括代码，要么加载自身的代码。</p>
<p>linux要求代码需要是只读的。防止被随意篡改。</p>
<p>代码很短的时候，到不了一个页，应该怎么装？</p>
<p>正是因为代码需要只读，而数据则是频繁变化的，因此它们一定要分头加载，装入两个不同的页中。<br>而这一“分头的”的操作并没有体现在代码上，原因在于<code>ZMAGIC</code>，魔数。</p>
<blockquote>
<p>内核在必要时从二进制文件中加载独立的页面，执行头部，代码段和数据段都被链接程序处理成多个页面大小的块。内核加载的代码页是只读的，数据段的页面是可写的。</p>
</blockquote>
<p>随后进行检验，拷贝环境变量。</p>
<p>一个文件具有inode，它的路径有另一个文件的内容指向，而它本身的inode又有另一个文件指向。最终最后一个就是根inode.</p>
<blockquote>
<p>内存中的inode内容要比硬盘中的inode内容多一点。</p>
</blockquote>
<p>根据之前读到的文件头与进程关联。注意，此时并没有加载。</p>
<p>加载之前首先要与父进程脱离关系。<br>首先就是清理。</p>
<p>由当前进程脱钩。</p>
<p><code>free_page_tables</code><br>清空页表项和页目录表，为何以ldt为标准？<br>因为结构都是线性的，按照线性吵结构清空即可。<br>要想脱离父进程，就把它的那份与父进程共享的代码和数据清空。</p>
<blockquote>
<p>注意：这里仅仅是把它的这份放掉，父进程自己还有一份，不受影响。</p>
</blockquote>
<p>接下来又要修改ldt。为什么要改它？<br>父子进程共享，线性并没有共享。<br><code>copy_process</code>之后的的<code>copy_mem</code>其中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_data_base = new_code_base - nr* 0x4000000</div></pre></td></tr></table></figure></p>
<p>其中<code>nr</code>来自于<code>copy_process</code>，<code>find_empty_process</code>遍历<code>task</code>数组之后返回<code>nr</code>，父子进程<code>nr</code>不同，线性地址空间也不同。</p>
<blockquote>
<p>父子进程共享的时候，把限长也共享了。虽然每页有64MB，但并不需要把它全占满。原则：够用即可。卡到8MB，多了也不给。</p>
</blockquote>
<p>新的操作系统，一个进程占满4G线性地址空间，并且内核与用户共用。<br>特权级问题：代码能随便跳特权级吗？</p>
<blockquote>
<p>只考虑段，可以。特权级落实到内存上但是在CPU上动手。实际上是CPU寻址权限控制/访问权限控制。执行谁的代码就是谁的特权级。<br>实际上还是可以阻止这种做法。<code>分界。</code>内存分页的时候，卡到某一位置剩下的就不分配了，即使有线性地址也不能访问。无论是内核和用户，都要经过内存分页。<br>将用户段与内核段线性排列而非重合，可以吗？不可以。因为系统代码使得内核线性地址空间就16MB，也就是当时linus的机器的物理内存。内核的线性地址宽度至少要覆盖物理内存。必须要覆盖全部内存，为了获得最大寻址。用来管理内存分页。否则没有分页的内存不能用。</p>
<p>段间跳转仅限于同特权级。内核不是通过线性地址来管理内存的，并不需要通过段间跳转来管理。但它仍然可以通过内存分页管理，直接动页物理地址。这时段的作用被淡化，内核线性地址顶两头。</p>
</blockquote>
<p><code>change_idt</code><br>父进程的线性地址，与子进程的线性地址并不共享。创建进程时<code>nr* 0x4000000</code>已经给了不同的基址，不变的就是限长。<br>证据：</p>
<ul>
<li><code>copy_mem</code>只设置了段基址，根本没有动限长。</li>
<li>在它之前的<code>copy_process</code>也只是拷贝了ldt tss，其中限长直接继承了，而且没有改动过。</li>
<li><code>copy_page_tables</code>接受的<code>data_page_limit</code>也是由<code>get_limit</code>获得的父进程的限长，没有更改过。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/操作系统/">操作系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/16/Linux Kernel-11-16/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/16/Linux Kernel-11-16/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/Linux Kernel-11-02/" title="Linux内核 11-02" itemprop="url">Linux内核 11-02</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T12:30:00.000Z" itemprop="datePublished"> 发表于 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="2015-11-2"><a href="#2015-11-2" class="headerlink" title="2015-11-2"></a>2015-11-2</h3><p>當前進程</p>
<blockquote>
<p>編程手冊:任務切換</p>
</blockquote>
<p>現場保護 保存段面</p>
<p>進程0創建進程一 tss ljmp 實際含義 硬件操作 彈出進程一的tss1給cpu 其中重要的是eip</p>
<p><strong>這個時候也需要保存現場，當前還是進程0，還需要恢復進程0的現場。執行跳轉的哪一個段面需要送到tss0</strong>，期間執行了多次壓棧。</p>
<blockquote>
<p>這與一般程序的壓棧過程不同。這裏是結構體，一般程序是棧。棧的規則是後進先出，而結構體應該有選擇哪個數據彈出的功能。整個保存西現場，恢復現場的工作都由一行代碼ljmp完成，其他工作由硬件電路完成。</p>
</blockquote>
<p>這一行執行完畢，將gdt中tss0彈出。此時ljmp是0特權級的代碼，操作的是內核資源。跳轉之後是3特權級代碼。<br>這一代碼並沒有寫出明確的特權級跳轉操作，然而實際上的確進行了跳轉。這就引出了<strong>門</strong>的概念，任務門，中斷門等等。</p>
<p>首先為什麼要設定特權級？</p>
<blockquote>
<ul>
<li>保護內核代碼，防止低特權級代碼篡改繫統關鍵信息</li>
<li>創造特權壁壘，不論3特權級代碼如何設計，都不會進入繫統內核</li>
<li>同時保證正常程序能夠進行繫統調用，使用內核代碼</li>
</ul>
</blockquote>
<h4 id="門"><a href="#門" class="headerlink" title="門"></a>門</h4><p>禁止的是跳轉的任意性/主動性，允許的是繫統指定的地方，跳轉到指定的目的，一切都是有既定規則/計劃的/被動的。</p>
<p>中斷並不是一個任意的行為。是在繫統監督下，使用固定的繫統資源int80 idt system_call進行的繫統操作。</p>
<blockquote>
<p>也就是說，特權級壁壘實際上是為了保護使用跳轉機制對繫統資源使用的正確性，使idt真實有效地管理繫統資源。跳轉機制是為了維護特權級壁壘的堅固，保證idt不被隨意篡改。</p>
</blockquote>
<p>然而這一行代碼是怎麼實現特權級切換的？</p>
<blockquote>
<p>tss存儲了一大堆寄存器信息，而特權級實際上是一種存儲的訪問控制機制，通過硬件的設置，來控制存儲的訪問權限。從tss一變，那麽寄存器中各種指針也相應地發生了變化，這樣段地址，指令地址都變了。而特權級是作用於段上的，段變了，特權級也就相應地變了。</p>
</blockquote>
<p>硬件的設置，保證了一個跳轉，必須有當前段，即起跳段，和目標段。而這兩個段的地址CPU都已經知道了，並且允許這個跳轉/尋址執行，同時執行一個中斷。</p>
<blockquote>
<p>CPU對特權級的執行，體現在它對尋址過程的放行與否。它將通常的尋址禁止，而放行從特殊位置來的尋址請求。</p>
</blockquote>
<p><strong>《Intel繫統編程手冊》</strong></p>
<p>這一行執行之後，進入繫統中斷int80 system_call，就跳轉到地方執行了。那麽往下的半個函數的程序，什麼時候執行？</p>
<blockquote>
<p>當前是0進程，中斷先保護0的現場，彈出1的地址，本來函數中下一行代碼地址在eip中，由於中斷保護現場，它被存到了進程0的tss中，因此當進程0的現場恢復的時候，恢復了tss0，就會執行下一行。</p>
</blockquote>
<p>所以在下次schedule.switch_to時，就會恢復tss，於是接下來執行後半個函數。</p>
<h3 id="ljmp后緩衝區的創建"><a href="#ljmp后緩衝區的創建" class="headerlink" title="ljmp后緩衝區的創建"></a>ljmp后緩衝區的創建</h3><h4 id="sys-setup函數與緩衝區"><a href="#sys-setup函數與緩衝區" class="headerlink" title="sys_setup函數與緩衝區"></a>sys_setup函數與緩衝區</h4><p>開始一大堆都是根文件繫統的初始化。</p>
<p><strong>緩衝區</strong></p>
<blockquote>
<p>操作繫統對硬盤的操作，都是經過緩衝區（內存）的中轉。目的∶快。關鍵∶<strong>複用</strong>。並不是每個讀寫操作，都使用硬盤。而是將重複的內容寫入內存，需要的時候提供內存中的這個副本。內存的讀寫速度可比硬盤快太多了。緩衝區就相當於一塊高速虛擬盤。它以塊為單位。</p>
</blockquote>
<p>複用策略</p>
<p>主動邀請，被動等待</p>
<p>等待的代價是佔用內存。存的時間長，其他進程效率就低，短複用就少。需要平衡二者的矛盾。</p>
<p>讀使用上述策略是可行的。那麽寫呢？</p>
<p>考慮到寫的內容有可能多次更改，以及其他用戶併發地訪問，這樣就又涉及到非常多的讀操作。於是由讀操作的優勢，寫操作同樣也需要緩衝區。</p>
<p>而什麼時候將緩衝區內容dump到硬盤呢？這由操作繫統的策略決定。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/操作系统/">操作系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/02/Linux Kernel-11-02/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/02/Linux Kernel-11-02/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/02/Linux Kernel-problems/" title="Linux内核 思考题" itemprop="url">Linux内核 思考题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Mingholy" target="_blank" itemprop="author">Mingholy</a>
		
  <p class="article-time">
    <time datetime="2015-11-02T12:30:00.000Z" itemprop="datePublished"> 发表于 2015-11-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="操作系统最后的36道思考题"><a href="#操作系统最后的36道思考题" class="headerlink" title="操作系统最后的36道思考题"></a>操作系统最后的36道思考题</h1><h3 id="1-为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？"><a href="#1-为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？" class="headerlink" title="1.为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？"></a>1.为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？</h3><p>因为开机加电的一瞬间，内存中没有程序。而CPU中的逻辑电路被设计成运行内存中的程序，没有能力直接从软盘中运行操作系统。要想运行操作系统，必须通过BIOS将操作系统程序加载到内存中。因此需要首先执行BIOS代码。</p>
<h3 id="2-为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？"><a href="#2-为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？" class="headerlink" title="2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？"></a>2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？</h3><p>因为不同的计算机可能具有不同的BIOS，而一台计算机也可能安装不同的操作系统。为了使BIOS与操作系统能够协同工作，现行的解决方法是“两头约定”和“定位识别”。“约定”操作系统的设计者必须把最开始执行的程序固定在启动扇区，即软盘0盘面0磁道1扇区。“定位识别”是指BIOS一旦接到启动操作系统的命令，就只从上述规定的启动扇区加载代码到0x07c00位置。之后的代码由于不同操作系统设计的内容不同，加载它们的时间、内容也不同，BIOS不能也没有必要来承担后续代码加载的工作，而是交由操作系统代码本身来执行，这就确保了同一台计算机能够正确运行不同的操作系统。</p>
<h3 id="3-为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？"><a href="#3-为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？" class="headerlink" title="3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？"></a>3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？</h3><p>0x00000之后的1KB用来存放中断向量表，再之后的256B构建了BIOS数据区。<br>0x07c00是由BIOS根据“两头约定”和“定位识别”原则确定的。加载后复制自身到0x90000是操作系统本身代码的执行，是操作系统的行为，代表着操作系统开始按照自己的意图规划内存。加载操作系统代码需要遵守“两头约定”和“定位识别”原则，由BIOS来执行。不能在操作系统还未加载的时候就先行决定。</p>
<h3 id="4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"><a href="#4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。" class="headerlink" title="4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"></a>4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。</h3><p>首先BIOS加载bootsect。bootsect通过load_setup中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mov dx, #0x0000</div><div class="line">mov cx, #0x0002</div><div class="line">mov bx, #0x0200</div><div class="line">mov ax, #0x0200 + SETUPLEN ;SETUPLEN 为4</div><div class="line">int 0x13</div></pre></td></tr></table></figure><br>读入setup程序的4个扇区。接着继续加载以<code>head.s</code>开头的system模块。加载完毕后通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmpi 0, SETUPSEG</div></pre></td></tr></table></figure><br>执行setup代码。在setup程序进行了一系列实模式-保护模式过渡准备工作之后，通过GDT来确定<code>head.s</code>的位置并执行它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmpi 0, 8</div></pre></td></tr></table></figure><br>这里将<code>8</code>看成<code>1000</code></p>
<blockquote>
<p>int 0x19中断指向的中断服务程序是由BIOS设计好的，用来加载bootsect。<code>bootsect.s</code>中load_setup用来加载setup<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">load_setup:</div><div class="line">mov dx, #0x0000</div><div class="line">mov cx, #0x0002</div><div class="line">mov bx, #0x0200</div><div class="line">mov ax, #0x0200 + SETUPLEN ;SETUPLEN 为4</div><div class="line">int 0x13</div><div class="line">jnc ok_load_setup</div><div class="line">mov dx, #0x0000</div><div class="line">mov ax, #0x0000</div><div class="line">int 0x13</div><div class="line">j load_setup</div></pre></td></tr></table></figure><br>指定了系统要读盘的位置和扇区数之后，转入int 0x13将setup的4个扇区代码读入。<br>在bootsect接着加载system模块进内存之后，通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmpi 0, SETUPSEG</div></pre></td></tr></table></figure><br>开始继续执行setup程序代码。setup关闭中断，移动内核程序到内存起始位置覆盖BIOS，设置中断描述符表（IDT）和全局描述符表（GDT），将中断向量表的形式转化为中断描述符。接着打开A20，得到32位线性地址空间。重编程8259A可编程中断控制器，重新映射中断号，解决了原中断号与Intel内部中断冲突的问题。接下来将CR0寄存器第0位置1,<strong>开启保护模式</strong>。进入保护模式后，就需要根据GDT来确定后续执行程序的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jmpi 0, 8</div></pre></td></tr></table></figure><br>将8看成1000，表示0特权级下，0表（0位GDT，1位LDT）标号为1的项，即第二项。得到段基址为0x00000000,偏移为0。即system模块中的<code>head.s</code>。</p>
</blockquote>
<h3 id="5-setup程序里的cli是为了什么？"><a href="#5-setup程序里的cli是为了什么？" class="headerlink" title="5.setup程序里的cli是为了什么？"></a>5.setup程序里的cli是为了什么？</h3><p>关闭中断，避免中断在复制内核程序、由实模式中断向量表过渡到保护模式中断描述符表时介入。这是为了在实模式中断机制失效而保护模式中断机制尚未建立时，防止进入中断造成系统崩溃。</p>
<h3 id="6-setup程序的最后是jmpi-0-8-为什么这个8不能简单的当作阿拉伯数字8看待？"><a href="#6-setup程序的最后是jmpi-0-8-为什么这个8不能简单的当作阿拉伯数字8看待？" class="headerlink" title="6.setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？"></a>6.setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？</h3><p>“8”是保护模式下的段选择符，用于选择描述符表和描述符表项以及所要求的特权级。实际上此处的8应理解为0x00008。16位段描述符中高13位为索引，低3位为属性。即“8”代表1000,1为表中项序号，即表中第二项。之后的1位0代表所选择的表，0即GDT；末两位00代表段特权级，即0特权级。</p>
<h3 id="7-打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？"><a href="#7-打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？" class="headerlink" title="7.打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？"></a>7.打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？</h3><p>打开A20实际上是扩展了CPU的寻址空间，由实模式的16位扩大到保护模式的32位。但是此时仍然是保护模式，直至<code>setup.s</code>将CR0寄存器第0位置1。之后才是真正的32位保护模式。</p>
<h3 id="8-Linux是用C语言写的，为什么没有从main函数开始，而是先运行3个汇编程序，道理何在？"><a href="#8-Linux是用C语言写的，为什么没有从main函数开始，而是先运行3个汇编程序，道理何在？" class="headerlink" title="8.Linux是用C语言写的，为什么没有从main函数开始，而是先运行3个汇编程序，道理何在？"></a>8.Linux是用C语言写的，为什么没有从main函数开始，而是先运行3个汇编程序，道理何在？</h3><p>从main函数开始执行是一般应用程序的惯例，其实现需要编译器和操作系统为其完成一系列的支撑工作；而Linux是操作系统程序，是最底层的管理和支撑程序，没有其他程序为其执行做支撑，上电时只能在实模式下通过执行3个汇编程序完成向32位模式的转变，之后才可能执行main函数。40页</p>
<h3 id="9-为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。"><a href="#9-为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。" class="headerlink" title="9.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。"></a>9.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。</h3><p>因为在由head程序向main函数跳转时，是不需要main函数返回的；这是由于main函数已经是最底层的函数了，没有更底层的支撑函数支持其返回。所以Linux采用ret指令，模拟函数返回，跳转到main函数去执行。  38页</p>
<h3 id="10-保护模式的“保护”体现在哪里？"><a href="#10-保护模式的“保护”体现在哪里？" class="headerlink" title="10.保护模式的“保护”体现在哪里？"></a>10.保护模式的“保护”体现在哪里？</h3><ul>
<li>保护模式下，对寄存器和内存空间的访问有等级限制，这样防止了用户程序任意串改系统代码。例如，只有在0特权级下才能对控制寄存器进行读写，而在其他特权级下，这种操作是不允许的</li>
<li>采用分页机制，用户进程对内存的读写使用的是线性地址，即基址+偏移<br>402页</li>
</ul>
<h3 id="11-特权级的目的和意义是什么？为什么特权级是基于段的？"><a href="#11-特权级的目的和意义是什么？为什么特权级是基于段的？" class="headerlink" title="11.特权级的目的和意义是什么？为什么特权级是基于段的？"></a>11.特权级的目的和意义是什么？为什么特权级是基于段的？</h3><p>特权级是操作系统为了更好的管理内存空间而设的，提高了系统的安全性。通过段，系统划分了内核代码段、内核数据段、用户代码段和用户数据段等不同的数据段，有些段是系统专享的，有些是和用户程序共享的，因此就有特权级的概念。 398~405页</p>
<h3 id="12-在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？"><a href="#12-在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？" class="headerlink" title="12.在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？"></a>12.在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？</h3><p>30页</p>
<h3 id="13-在head程序执行结束的时候，在idt的前面有184个字节的head程序的剩余代码，剩余了什么？为什么要剩余？"><a href="#13-在head程序执行结束的时候，在idt的前面有184个字节的head程序的剩余代码，剩余了什么？为什么要剩余？" class="headerlink" title="13.在head程序执行结束的时候，在idt的前面有184个字节的head程序的剩余代码，剩余了什么？为什么要剩余？"></a>13.在head程序执行结束的时候，在idt的前面有184个字节的head程序的剩余代码，剩余了什么？为什么要剩余？</h3><p>通过运行Linux-0.11代码，可以看到剩余的代码是标号after_page_tables之后head程序中的代码。因为head程序共占用25KB+184B的内存空间，系统在建立好分页机制和GDT、IDT之后，在内存空间0x05400-0x54b8处留有184B的空间未使用，因此产生了剩余。</p>
<h3 id="14-进程0的task-struct在哪？具体内容是什么？给出代码证据。"><a href="#14-进程0的task-struct在哪？具体内容是什么？给出代码证据。" class="headerlink" title="14.进程0的task_struct在哪？具体内容是什么？给出代码证据。"></a>14.进程0的task_struct在哪？具体内容是什么？给出代码证据。</h3><p>在内核数据段。进程0的管理结构task_struct的母本在代码设计阶段就视线设计好了，直接编译加载进内核数据段。内容有状态、信号、pid、alarm、ldt、tss等管理该进程所需的数据。代码证据：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Sched.c:</div><div class="line">  uniontask_union &#123;</div><div class="line">  structtask_struct task;</div><div class="line">  <span class="keyword">char</span> <span class="built_in">stack</span>[PAGE_SIZE];</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">union</span> task_unioninit_task = &#123;INIT_TASK,&#125;;</div></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Sched.h:</div><div class="line">  <span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></div><div class="line">  <span class="comment">/* state etc */</span> &#123; 0,15,15, \</div><div class="line">  <span class="comment">/* signals */</span> 0,&#123; &#123;&#125;,&#125;,0, \</div><div class="line">  <span class="comment">/* ec,brk... */</span> 0,0,0,0,0,0, \</div><div class="line">  <span class="comment">/* pid etc.. */</span> 0,-1,0,0,0, \</div><div class="line">  <span class="comment">/* uidetc */</span> 0,0,0,0,0,0, \</div><div class="line">  <span class="comment">/* alarm */</span> 0,0,0,0,0,0, \</div><div class="line">  <span class="comment">/* math */</span> 0, \</div><div class="line">  <span class="comment">/* fs info */</span>  -1,0022,NULL,NULL,NULL,0, \</div><div class="line">  <span class="comment">/* filp */</span> &#123;NULL,&#125;\, \</div><div class="line">  &#123; \</div><div class="line">  &#123;0,0&#125;, \</div><div class="line">  <span class="comment">/* ldt */</span> &#123;0x9f,0xc0fa00&#125;, \</div><div class="line">  &#123;0x9f,0xc0f200&#125;, \</div><div class="line">  &#125;, \</div><div class="line">  <span class="comment">/*tss*/</span> \&#123;0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\</div><div class="line">  0,0,0,0,0,0,0,0, \</div><div class="line">  0,0,0x17,0x17,0x17,0x17,0x17,0x17, \</div><div class="line">  _LDT(0),0x80000000, \</div><div class="line">  &#123;&#125; \</div><div class="line">  &#125;, \</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h3 id="15-进程0创建进程1时，为进程1建立了自己的task-struct、内核栈，第一个页表，分别位于物理内存16MB的顶端倒数第一页、第二页。请问，这个了页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间（直接从物理地址分配）？说明理由并给出代码证据。"><a href="#15-进程0创建进程1时，为进程1建立了自己的task-struct、内核栈，第一个页表，分别位于物理内存16MB的顶端倒数第一页、第二页。请问，这个了页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间（直接从物理地址分配）？说明理由并给出代码证据。" class="headerlink" title="15.进程0创建进程1时，为进程1建立了自己的task_struct、内核栈，第一个页表，分别位于物理内存16MB的顶端倒数第一页、第二页。请问，这个了页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间（直接从物理地址分配）？说明理由并给出代码证据。"></a>15.进程0创建进程1时，为进程1建立了自己的task_struct、内核栈，第一个页表，分别位于物理内存16MB的顶端倒数第一页、第二页。请问，这个了页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间（直接从物理地址分配）？说明理由并给出代码证据。</h3><p>两次都是通过调用get_free_page()在物理内存里申请一个物理页，由于在head.s中决定内核的物理地址和线性地址是一一对应的。因此这两个页都在内核的线性地址空间内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">setup_paging:</div><div class="line">movl $1024*5,%ecx</div><div class="line">/* 5 pages - pg_dir+4 page tables*/</div><div class="line">xorl %eax,%eax</div><div class="line">xorl %edi,%edi</div><div class="line">/* pg_dir is at 0x000*/</div><div class="line">cld;rep;stosl</div><div class="line">movl $pg0+7,_pg_dir</div><div class="line">/* set present bit/user r/w*/</div><div class="line">movl $pg1+7,_pg_dir+4</div><div class="line">/*  --------- &quot; &quot; ---------*/</div><div class="line">movl $pg2+7,_pg_dir+8</div><div class="line">/*  --------- &quot; &quot; ---------*/</div><div class="line">movl $pg3+7,_pg_dir+12</div><div class="line">/*  --------- &quot; &quot; ---------*/</div><div class="line">movl $pg3+4092,%edi</div><div class="line">movl $0xfff007,%eax</div><div class="line">/*  16Mb - 4096 + 7 (r/w user,p)*/</div><div class="line">std</div><div class="line">1: stosl</div><div class="line">/* fill pages backwards - more efficient :-)*/</div><div class="line">subl $0x1000,%eax  </div><div class="line">jge 1b</div></pre></td></tr></table></figure>  </p>
<h3 id="16-假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"><a href="#16-假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。" class="headerlink" title="16.假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"></a>16.假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。</h3><p>两个页表均占用内核的线性地址空间</p>
<h3 id="17-进程0开始创建进程1，调用了fork-，跟踪代码时我们发现，fork代码执行了两次，第一次，跳过init-直接执行了for-pause-，第二次执行fork代码后，执行了init-。奇怪的是，我们在代码中并没有看见向后的goto语句，也没有看到循环语句，是什么原因导致反复执行？请说明理由，并给出代码证据。"><a href="#17-进程0开始创建进程1，调用了fork-，跟踪代码时我们发现，fork代码执行了两次，第一次，跳过init-直接执行了for-pause-，第二次执行fork代码后，执行了init-。奇怪的是，我们在代码中并没有看见向后的goto语句，也没有看到循环语句，是什么原因导致反复执行？请说明理由，并给出代码证据。" class="headerlink" title="17.进程0开始创建进程1，调用了fork()，跟踪代码时我们发现，fork代码执行了两次，第一次，跳过init()直接执行了for(;;) pause()，第二次执行fork代码后，执行了init()。奇怪的是，我们在代码中并没有看见向后的goto语句，也没有看到循环语句，是什么原因导致反复执行？请说明理由，并给出代码证据。"></a>17.进程0开始创建进程1，调用了fork()，跟踪代码时我们发现，fork代码执行了两次，第一次，跳过init()直接执行了for(;;) pause()，第二次执行fork代码后，执行了init()。奇怪的是，我们在代码中并没有看见向后的goto语句，也没有看到循环语句，是什么原因导致反复执行？请说明理由，并给出代码证据。</h3><p>大致过程是：进程0在创建进程1时，判断条件中执行了第一次的<code>fork()</code>，这个时候没有写时复制，不能执行需要栈空间的函数。因此按照之前的定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> _syscall0(<span class="keyword">int</span>, fork)</div></pre></td></tr></table></figure><br><code>fork()</code>应该执行<code>_syscall0</code>中的<code>fork(void)</code>。经过一系列汇编代码的嵌入，最终会有这样的函数形式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int fork(void)</div><div class="line">&#123;</div><div class="line">long __res;</div><div class="line">__asm__ volatile("int $0x80"</div><div class="line"></div><div class="line">    : "=a" (__res)</div><div class="line">    : "0" (__NR_ fork));    </div><div class="line">    </div><div class="line">    if (__res &gt;= 0)</div><div class="line">    return (int) __res;</div><div class="line">    errno= -__res;</div><div class="line">    return -1；</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>可见函数中调用了 int 0x80，显然需要各种压栈（按照顺序是：CPU硬件自动压栈：ss,esp,eflags,cs,eip；_system_call压栈：ds,es,fs,edx,ecx,ebx;<code>_sys_call_table</code>自动压栈对应的参数：long none；<code>_sys_fork</code>压栈：gs,esi,edi,ebp,eax（对应nr））。其中重要的是将eip的值设置为了返回之后的下一行，即<br>    if (<strong>res &gt;= 0)<br>之后调用<code>copy_process()</code>所用的所有参数，就是上面压栈的那些。<code>copy_process()</code>将这些寄存器的内容复制给了进程1的tss，值得注意的一点是，并不是所有的都复制了，其中进程1的eax就手动赋了0，而进程0是1。经过一系列分页设置、共享文件、设置GDT、修改状态之后，中断恢复，回到eip所指向的那条指令。此时eax存储的是1，返回给if判断不通过，于是执行<code>for(;;) pause</code>。之后通过进程调度进程1开始运行时，同样到了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!fork())</div></pre></td></tr></table></figure><br>这里，执行了第二次<code>fork()</code>。由于进程1的tss中eax手动赋了0，于是在上面第二次int 0x80返回后，`</strong>res=0<code>,返回给if语句后判断通过，就执行了</code>init()`。</p>
<h3 id="18-copy-process函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。"><a href="#18-copy-process函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。" class="headerlink" title="18.copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。"></a>18.copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。</h3><p>是由int 0x80在中断时通过cpu硬件自动压栈的。并不会体现在代码上。见20题。</p>
<h3 id="19-为什么static-inline-syscall0-type-name-中需要加上关键字inline？"><a href="#19-为什么static-inline-syscall0-type-name-中需要加上关键字inline？" class="headerlink" title="19.为什么static inline _syscall0(type,name)中需要加上关键字inline？"></a>19.为什么static inline _syscall0(type,name)中需要加上关键字inline？</h3><p>从内核空间创建进程将导致没有写时复制，直到执行一个execve调用。这可能给堆栈带来问题。处理方法是在<code>fork()</code>调用之后，禁止<code>main()</code>使用任何堆栈。因此就不能进行函数调用，这样<code>fork()</code>就也只能使用inline代码。否则<code>main()</code>中的其他代码运行时有可能再开辟堆栈空间污染原有栈数据。</p>
<h3 id="20-根据代码详细说明copy-process函数的所有参数是如何形成的？"><a href="#20-根据代码详细说明copy-process函数的所有参数是如何形成的？" class="headerlink" title="20.根据代码详细说明copy_process函数的所有参数是如何形成的？"></a>20.根据代码详细说明copy_process函数的所有参数是如何形成的？</h3><p><code>copy_process</code>的所有参数都是由之前的代码累积压栈得到的。<br>代码证据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">;代码路径：kernel/system_call.s:</div><div class="line">_system_call:</div><div class="line">    cmpl $nr_system_calls-1, %eax</div><div class="line">    ja bad_sys_call</div><div class="line">    push %ds</div><div class="line">    push %es</div><div class="line">    push %fs</div><div class="line">    pushl %edx</div><div class="line">    pushl %ecx</div><div class="line">    pushl %ebx</div><div class="line">    ...</div></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_sys_fork:</div><div class="line">    call _find_empty_process</div><div class="line">    testl %eax, %eax</div><div class="line">    js 1f</div><div class="line">    push %gs</div><div class="line">    pushl %esi</div><div class="line">    pushl %edi</div><div class="line">    pushl %ebp</div><div class="line">    pushl %eax</div><div class="line">    call _copy_process</div><div class="line">    ...</div></pre></td></tr></table></figure><br>其中最后压栈的eax是<code>find_empty_process()</code>返回的任务号，就是<code>copy_process()</code>函数的第一个参数int nr，以及int 0x80在中断时自动压栈的eip，cs，eflags，esp，ss，这些一起构成了<code>copy_process()</code>函数的第所有参数。</p>
<h3 id="21-根据代码详细分析，进程0如何根据调度第一次切换到进程1的。"><a href="#21-根据代码详细分析，进程0如何根据调度第一次切换到进程1的。" class="headerlink" title="21.根据代码详细分析，进程0如何根据调度第一次切换到进程1的。"></a>21.根据代码详细分析，进程0如何根据调度第一次切换到进程1的。</h3><p><code>fork()</code>-&gt;<code>_syscall0</code>-&gt;int 0x80-&gt;<code>_sys_call</code>-&gt;<code>sys_fork</code>-&gt;<code>copy_process</code>-&gt;<code>get_free_page</code>-&gt;<code>copy_mem</code>-&gt;<code>get_free_page</code>-&gt;进程0怠速：<code>pause()</code>-&gt;<code>schedule()</code>-&gt;判断<code>if(!fork())</code>到<code>init()</code>-&gt;设置硬盘信息、建立缓冲区，开始执行。82-110页</p>
<h3 id="22-内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。"><a href="#22-内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。" class="headerlink" title="22.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。"></a>22.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。</h3><p>首先是1个页的也目录表，然后是4个页的页表，然后是若干个页。<br>页目录表的第一项指向第一个页表，以此类推，第四项指向第四个页表。<br>页表的第一个页表项指向第1个页，即页0，也就是页目录表所在的页。第二项指向自己，第三项指向第二个页表，以此类推。之后的页表项指向之后的页。</p>
<h3 id="23-用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set-trap-gate-0-amp-divide-error-），并给出代码证据。"><a href="#23-用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set-trap-gate-0-amp-divide-error-），并给出代码证据。" class="headerlink" title="23.用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set_trap_gate(0,&amp;divide_error)），并给出代码证据。"></a>23.用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set_trap_gate(0,&amp;divide_error)），并给出代码证据。</h3><p>初始化中断描述符表即将中断服务程序与中断描述符表中的项一一对应。<br><code>set_trap_gate(0,&amp;divede_error)</code>对应宏函数<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#define _set_gate(gate_addr,type,dp1,addr) \</div><div class="line">__asm__("movw %%dx, %%ax\n\t") \</div><div class="line">        "movw %0, %%dx\n\t" \</div><div class="line">        "movl %%eax, %1\n\t" \</div><div class="line">        "movl %%edx, %2" \</div><div class="line">        : \</div><div class="line">    : "i" ((short) (0x8000 + (dpl&lt;&lt;13) + (type&lt;&lt;8))), \</div><div class="line">        "o" (*((char *) (gate_addr))), \</div><div class="line">        "o" (*(4+(char *) (gate_addr))), \</div><div class="line">        "d" ((char *) (addr)), "a" (0x00080000)</div><div class="line">    ...</div></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr)</span></div><div class="line">    _set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr)</div></pre></td></tr></table></figure><br>55页</p>
<h3 id="24-进程0-fork进程1之前，为什么先要调用move-to-user-mode-？用的是什么方法？解释其中的道理。"><a href="#24-进程0-fork进程1之前，为什么先要调用move-to-user-mode-？用的是什么方法？解释其中的道理。" class="headerlink" title="24.进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。"></a>24.进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。</h3><p>因为在Linux-0.11中，除进程0之外，所有进程都是由一个已有进程在用户态下完成创建的。但是此时进程0还处于内核态，因此要调用<code>move_to_user_mode()</code>函数，模仿中断返回的方式，实现进程0的特权级从内核态转化为用户态。又因为在Linux-0.11中，转换特权级时采用中断和中断返回的方式，调用系统中断实现从3到0的特权级转换，中断返回时转换为3特权级。因此，进程0从0特权级到3特权级转换时采用的是模仿中断返回。</p>
<h3 id="25-进程0创建进程1时调用copy-process函数，在其中直接、间接调用了两次get-free-page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。"><a href="#25-进程0创建进程1时调用copy-process函数，在其中直接、间接调用了两次get-free-page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。" class="headerlink" title="25.进程0创建进程1时调用copy_process函数，在其中直接、间接调用了两次get_free_page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。"></a>25.进程0创建进程1时调用copy_process函数，在其中直接、间接调用了两次get_free_page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。</h3><p>第一次是创建进程1的tss和内核态栈：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p = (<span class="keyword">struct</span> task_struct *) get_free_page();</div><div class="line">*p = *current</div><div class="line">p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</div></pre></td></tr></table></figure><br>第二次是位进程1创建第一个页表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">*to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</div></pre></td></tr></table></figure></p>
<h3 id="26-在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0-11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。"><a href="#26-在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0-11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。" class="headerlink" title="26.在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。"></a>26.在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。</h3><ul>
<li>cli指令用于复位IF标志位。在IA-32体系结构中规定，只有当CPL小于或等于IOPL时才可以执行该指令。如果在CPL大于IOPL的情况下执行，将会产生一个一般保护异常（#GP）。保护异常(#GP)是interrupt 0x13， 在<code>trap_init()</code>中设置<br>–set_trap_gate(13,&amp;general_protection);</li>
<li>IA32硬件规定，在执行CLI指令的时候，当前代码的特权级数值上必须不高于当前EFLAGS寄存器中IOPL字段的值。进程0的EFLAGS值设置为0，后续进程如果没有改动也是0，IOPL=0。因此特权级3的代码不能用cli。</li>
</ul>
<h3 id="27-根据代码详细分析操作系统是如何获得一个空闲页的。"><a href="#27-根据代码详细分析操作系统是如何获得一个空闲页的。" class="headerlink" title="27.根据代码详细分析操作系统是如何获得一个空闲页的。"></a>27.根据代码详细分析操作系统是如何获得一个空闲页的。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">unsigned long get_free_page(void)</div><div class="line">&#123;</div><div class="line">register unsigned long __res asm(&quot;ax&quot;);</div><div class="line"></div><div class="line">__asm__(&quot;std;repne;scasb\n\t&quot;)</div><div class="line"></div><div class="line">        &quot;jne 1f\n\t&quot;</div><div class="line">        &quot;movb $1, 1(%%edi)\n\t&quot;</div><div class="line">        </div><div class="line">        &quot;sall $12, %%ecx\n\t&quot;</div><div class="line">        &quot;addl %2,%%ecx\n\t&quot;</div><div class="line">        &quot;movl %%ecx,%%edx\n\t&quot;</div><div class="line">        &quot;movl $1024,%%ecx\n\t&quot;</div><div class="line">        &quot;leal 4092(%%eax),%%edi\n\t&quot;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>89页 注释：首先反向扫描串<code>mem map[]</code>，<code>al(0)</code>与di不等则重复寻找引用对数为0的项。若找不到空闲页，跳转到1。否则将1赋值给edi+1的位置，使，在<code>mem map[]</code>中，将找到0的项的引用计数置1。接着将ecx算数左移12位，即页的相对地址。LOW MEN + ecx作为页的物理地址。将edx + 4 KB的有效地址赋给edi。将eax（即<code>&quot;0&quot;(0)</code>），目的是页面清零。</p>
<h3 id="28-用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？"><a href="#28-用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？" class="headerlink" title="28.用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？"></a>28.用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？</h3><p>用户代码段的特权级都是3，内核特权级是0，跨特权长跳转是被禁止的，不管是0跳3还是3跳0。这一特权级壁垒，是由CPU硬件做到的。GDT，LDT这两个数据结构被设置在内核数据区，是0特权级，只有0特权级才能修改设置GDT，LDT。而用户进程自己设计的LDT不会被CPU承认，因为真正有效的GDT、LDT需要挂接在CPU的GDTR、LDTR上，CPU只承认它们指向的数据结构，并且设置GTDR、LDTR的操作也能且只能在0特权级下进行。<br>259页</p>
<h3 id="29-保护模式下，线性地址到物理地址的转化过程是什么？"><a href="#29-保护模式下，线性地址到物理地址的转化过程是什么？" class="headerlink" title="29.保护模式下，线性地址到物理地址的转化过程是什么？"></a>29.保护模式下，线性地址到物理地址的转化过程是什么？</h3><p>保护模式：已经打开PE；<br>未打开PG：恒等映射，由于Linux 0.11的特性，只能在16MB空间内寻址；<br>打开PG：进行32位寻址，在IA-32体系下能够支持最多4GB物理内存。32位的线性地址需要通过MMU进行解析，以页目录表-页表-页面三级映射的形式进行线性地址-物理地址的转换。类似于GDT和GDTR，页目录表的基址在CPU中也有相应的空间存储，即CR3。MMU在解析线性地址时，首先查询CR3找到页目录表，根据前10位找到页目录项，该项内记载着页表的<strong>物理地址值</strong>，根据接下来的10位找到页表项，该项记载着页面的<strong>物理地址</strong>。接下来的12位表示页面内的偏移物理地址，这样就完成了线性地址到物理地址经过页目录表-页表-页面的三级映射。</p>
<h3 id="30-为什么get-free-page-将新分配的页面清0？"><a href="#30-为什么get-free-page-将新分配的页面清0？" class="headerlink" title="30.为什么get_free_page()将新分配的页面清0？"></a>30.为什么get_free_page()将新分配的页面清0？</h3><p>防止该位置之前已经存在的垃圾数据对新进程造成影响。</p>
<h3 id="31-内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？"><a href="#31-内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？" class="headerlink" title="31.内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？"></a>31.内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？</h3><p>虽然它们的线性地址空间不同，但是它们映射的物理地址可能重合。或者通过页面共享，访问同样的内容。但是不论是哪种方式，都需要对页面的特权级和读写保护进行严格的控制。</p>
<h3 id="32-详细分析一个进程从创建、加载程序、执行、退出的全过程。"><a href="#32-详细分析一个进程从创建、加载程序、执行、退出的全过程。" class="headerlink" title="32.详细分析一个进程从创建、加载程序、执行、退出的全过程。"></a>32.详细分析一个进程从创建、加载程序、执行、退出的全过程。</h3><ul>
<li><p>创建<br>首先，一个进程的创建必是由某个父进程来执行的。</p>
<p>用户创建进程，一般是shell创建。假设硬盘上有一可执行文件p，用户输入shell指令后，系统响应该指令并开始创建进程，调用<code>fork</code>，进入int 0x80中断。首先在task[64]中申请进程槽（项），并获得一个进程号，如5。随后根据该项号确定在哪个线性地址空间以及LDT和TSS的对应关系。</p>
<p>接下来创建进程skeleton。<code>copy_process()</code>调用<code>get_free_page</code>在内核线性地址空间中申请了task_struct和内核栈。接下来父进程shell将自己的task_stuct复制给p，因为这是一个不同的进程，还要进行个性化设置。之前要将其设置为不可中断等待状态。设置好包括进程号、父进程、TSS等内容之后，还要复制p本身的代码。这就要为进程分段，确定线性地址空间，即设置段基址和段限长。之前为了共享父进程的代码和数据，LDT都是继承父进程的，并且分页也是共享父进程的，只是创建了另一套页目录表项和页表项，指向父进程页面。文件同样继承父进程的。<br>接下来将TSS和LDT挂载在GDT指定位置处，建立段一级保护。最后设置其为就绪态。准备参加调度。</p>
</li>
<li>加载<br>首先检查页面空间、文件，确定其格式和规范合法正确。随后着手与父进程脱离关系，清空页目录表项和页表。重新设置LDT，调整task_struct。此时p没有页，执行将产生缺页中断。<code>trap_init</code>引导缺页中断，<code>_page_fault</code>中<code>_do_no_page</code>调用缺页处理函数,<code>_do_wp_page</code>调用写保护处理函数。首先确认缺页中断是加载进程引起的，接着确认是否可以通过共享获得页，<code>for</code>循环连读4个块。<code>block+1</code>让出文件头，<code>bread_page</code>是读一个页到缓冲区，占用4个块。读盘动作总要先申请缓冲区，一次从文件上读取一个页大小。缓冲区操作建立：<code>bh``request</code>。如果页不够用，就继续缺页中断，直至加载完毕。</li>
<li>执行<br>开辟栈空间供其使用，运行结束清空栈空间</li>
<li>退出<br>由进程自身发起。链接器在应用程序上加上<code>_exit</code>。直接贴机器码。走int 0x80 system_call那一套。<code>do_exit</code>执行各种内存释放操作。进程本身的退出还是要由父进程操作。此时只是发出请求并执行自身能够完成的任务：释放内存，清空进程槽，清空文件访问关系等。直至将进程状态改为<code>TASK_ZOMBIE</code>。最后不能使用<code>iret</code>而是调用<code>tell_father</code>。<br>通过进程通信机制向父进程发送退出信号，等待父进程调用int 0x80时接收信号。当父进程调度时，<code>do_signal</code>将处理信号，随后清栈。由于<code>do_signal</code>的作用（复制内核栈的内容到用户栈，修改内核栈使进程转向），父进程int 0x80返回后指向<code>wait</code>，引发<code>sys_waitpid</code>，开始清理，完成后根据用户栈的内容回到父进程用户态继续执行，至此子进程退出彻底完成。</li>
</ul>
<h3 id="33-详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。"><a href="#33-详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。" class="headerlink" title="33.详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。"></a>33.详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。</h3><p><code>share_page</code>与<code>try_to_share</code><br>首先调用<code>share_page</code>检查文件是否可执行、是否有其他进程打开过该文件。然后遍历task[]找到第一个打开该文件的进程，确认进程合法性之后调用<code>try_to_share</code>共享这个页。确认P位为1，D位为0，否则重新读盘；然后开启写保护读取该页。</p>
<h3 id="34-缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？"><a href="#34-缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？" class="headerlink" title="34.缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？"></a>34.缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？</h3><p>P位为1引发<code>trap_init</code>中关于第14位的缺页中断。调用<code>_do_no_page</code>处理函数、<code>_do_wp_page</code>写保护函数。见doc</p>
<h3 id="35-为什么要设计缓冲区，有什么好处？"><a href="#35-为什么要设计缓冲区，有什么好处？" class="headerlink" title="35.为什么要设计缓冲区，有什么好处？"></a>35.为什么要设计缓冲区，有什么好处？</h3><p>缓冲区的本质是一块内存，核心思想是资源的“复用”，目的是提高资源访问速度。因为内存访问速度比硬盘的访问速度快得多，如果同一个资源多次被读取，那么由硬盘一次性写入内存之后再多次从内存读出，将比每次都从硬盘读取快很多，使得系统执行效率得到很大的提升.</p>
<h3 id="36-操作系统如何利用buffer-head中的-b-data，b-blocknr，b-dev，b-uptodate，b-dirt，b-count，b-lock，b-wait管理缓冲块的？"><a href="#36-操作系统如何利用buffer-head中的-b-data，b-blocknr，b-dev，b-uptodate，b-dirt，b-count，b-lock，b-wait管理缓冲块的？" class="headerlink" title="36.操作系统如何利用buffer_head中的 b_data，b_blocknr，b_dev，b_uptodate，b_dirt，b_count，b_lock，b_wait管理缓冲块的？"></a>36.操作系统如何利用buffer_head中的 b_data，b_blocknr，b_dev，b_uptodate，b_dirt，b_count，b_lock，b_wait管理缓冲块的？</h3><ul>
<li>指针b_data指向数据块。</li>
<li>设备号b_blocknr和块号b_dev经常连用。一个块只有一个管理信息，存入的数据归属具有唯一性。</li>
<li>整个硬盘空间，每个块都是独立并且唯一存在的，通过设备号和块号两个参数唯一确定。</li>
<li>计数器b_count计数此时正在操作缓冲块的进程的个数。由于缓冲区没有撤销废除机制，所以只能说b_count=0的缓冲块，可以被替换，但并不是必须且立即的。</li>
<li>b_dirt脏位，表示块已经被写过。</li>
<li>b_lock表示当前块正在被操作，读或者写。</li>
<li>b_uptodate表示更新位。</li>
</ul>
<p>由进程到缓冲区/缓冲块之间的关系，由buffer_head管理，由缓冲区到外设io的关系，由request项管理，有单独的一段程序实现。</p>
<p>进程首先查询数据是否在缓冲区中存在。如果有就直接读。如果没有，看是否有空缓冲区，如果有建立缓冲块并与请求项建立关系。</p>
<p>分开管理有利于获得高效率。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/操作系统/">操作系统</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/11/02/Linux Kernel-problems/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/11/02/Linux Kernel-problems/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/3/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C++">C++<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Dubtitler/" title="Dubtitler">Dubtitler<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/SSH/Git/" title="Git">Git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/Hadoop/HBase/" title="HBase">HBase<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/Hadoop/" title="Hadoop">Hadoop<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/IFE2017/" title="IFE2017">IFE2017<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/JavaScript/" title="JavaScript">JavaScript<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Notes/" title="Notes">Notes<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/SSH/" title="SSH">SSH<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/人民南路四段九号/" title="人民南路四段九号">人民南路四段九号<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数学/" title="数学">数学<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/数学/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">4</span></li></ul>
  </div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/HTML/" title="HTML">HTML<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/上帝之语/" title="上帝之语">上帝之语<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hadoop/" title="Hadoop">Hadoop<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/编辑器/" title="编辑器">编辑器<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Graph-Compute/" title="Graph Compute">Graph Compute<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HBase/" title="HBase">HBase<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/DubtitlerDev/" title="DubtitlerDev">DubtitlerDev<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Be a live-wire artist, <br/>
			Do something amazing.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/mingholy" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:liminghao15@mails.ucas.ac.cn" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Mingholy">Mingholy</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script src="https://s4.cnzz.com/z_stat.php?id=1261294969&web_id=1261294969" language="JavaScript"></script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
